name: CI/CD Pipeline

on:
  push:
    branches:
      - main  # Déclenche l'action lors d'un push sur la branche main
  pull_request:
    branches:
      - main  # Déclenche l'action lors de la création d'une PR vers main

jobs:
  build:
    runs-on: ubuntu-latest  # Utilise un runner basé sur Ubuntu

    steps:
    # Étape 1 : Récupérer le code source
    - name: Checkout code
      uses: actions/checkout@v2

    # Étape 2 : Configurer Docker
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    # Étape 3 : Cacher les couches Docker pour accélérer le processus de build
    - name: Cache Docker layers
      uses: actions/cache@v2
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    # Étape 4 : Construire l'image Docker et la pousser (si nécessaire)
    - name: Build and push Docker image
      uses: docker/build-push-action@v2
      with:
        context: .
        push: false  # Mettre à true si tu veux pousser l'image vers un registre (ex: Docker Hub)
        tags: user_name/app_name:latest

    # Étape 5 : Lancer les tests avec Docker Compose
    - name: Run tests
      run: |
        docker-compose up -d  # Lancer les services en mode détaché
        docker-compose exec app pytest  # Lance les tests (remplace `app` par le nom de ton service)
        docker-compose down  # Arrêter et nettoyer les conteneurs après les tests

    # Étape 6 : Déploiement (si tu veux un déploiement automatique)
    - name: Deploy to production (exemple SSH)
      run: |
        ssh user@your_server "docker pull user_name/app_name:latest && docker-compose up -d"
