name: CI/CD Pipeline

on:
  push:
    branches:
      - main  # Déclenche l'action lors d'un push sur la branche main
  pull_request:
    branches:
      - main  # Déclenche l'action lors de la création d'une PR vers main

jobs:
  build:
    runs-on: ubuntu-latest  # Utilise un runner basé sur Ubuntu

    steps:
    # Étape 1 : Récupérer le code source
    - name: Checkout code
      uses: actions/checkout@v4

    # Étape 2 : Configurer Docker
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    # Étape 3 : Cacher les couches Docker pour accélérer le processus de build
    - name: Cache Docker layers
      uses: actions/cache@v2
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    # Étape 4 : Construire les images Docker pour chaque service
    - name: Build Docker image for service_a
      uses: docker/build-push-action@v2
      with:
        context: ./service_a  # Spécifier le contexte pour service_a
        file: ./service_a/Dockerfile
        push: false  # Mettre à true si on veut pousser l'image
        tags: user_name/service_a:latest

    - name: Build Docker image for service_b
      uses: docker/build-push-action@v2
      with:
        context: ./service_b  # Spécifier le contexte pour service_b
        file: ./service_b/Dockerfile
        push: false
        tags: user_name/service_b:latest

    # Étape 5 : Lancer les tests avec Docker Compose
    - name: Run tests
      run: |
        docker-compose up -d  # Lancer les services en mode détaché
        docker-compose exec service_a pytest  # Remplace par ton service qui gère les tests
        docker-compose down  # Nettoyer après les tests

    # Étape 6 : Déploiement (si nécessaire)
    - name: Deploy to production (exemple SSH)
      run: |
        ssh user@your_server "docker pull user_name/service_a:latest && docker pull user_name/service_b:latest && docker-compose up -d"
